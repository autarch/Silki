#!/usr/bin/perl

use strict;
use warnings;
use autodie qw( :all );

use lib './lib';

use File::Temp qw( tempdir );
use Getopt::Long;
use Path::Class qw( file );
use Silki::Config;

my %opts = ( seed => 1 );
GetOptions(
    'db:s'  => \$opts{db},
    'drop'  => \$opts{drop},
    'seed!' => \$opts{seed},
);

die "You must provide a database name with --db"
    unless $opts{db};

Silki::Config->dbi_config()->{name} = $opts{db};

print "\n";

if ( $opts{db} eq 'Silki' && ! $opts{drop} ) {
    check_for_existing_db();
}
else {
    recreate_db($opts{db});
}

build_db();

exit 0 unless $opts{seed};

seed_data();

sub check_for_existing_db {
    require Fey::DBIManager::Source;

    eval {
        Fey::DBIManager::Source->new(
            %{ Silki::Config->dbi_config() },
        )->dbh();
    };

    if ( !$@ ) {
        warn
            qq{\n  Will not drop a database called "Silki" unless you pass the --drop argument.\n\n};
        exit 1;
    }
}

sub seed_data {
    require Silki::SeedData;

    msg("Seeding the $opts{db} database");

    Silki::SeedData::seed_data('verbose');
}

sub recreate_db {
    my $command = <<"EOF";
SET CLIENT_MIN_MESSAGES = ERROR;

DROP DATABASE IF EXISTS "$opts{db}";

CREATE DATABASE "$opts{db}"
       ENCODING 'UTF8';
EOF

    my $dir = tempdir( CLEANUP => 1 );
    my $file = file( $dir, 'recreate-db.sql' );

    open my $fh, '>', $file;
    print {$fh} $command;
    close $fh;

    msg("Dropping and recreating the $opts{db} database");

    system( 'psql', 'template1', '-q', '-f', $file )
}

sub build_db {
    my $schema_file = file( 'schema', 'Silki.sql' );

    msg("Creating schema from $schema_file");

    system( 'psql', $opts{db}, '-q', '-f', $schema_file )
        and die 'Cannot create Silki database with psql';
}

sub msg {
    my $msg = shift;

    print "  $msg\n\n";
}
